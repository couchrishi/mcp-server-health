import subprocess
import json
import sys

# --- Trivy Specific Functions ---

def parse_trivy_output(json_output):
    """Parses Trivy JSON output to count HIGH and CRITICAL vulnerabilities."""
    counts = {'CRITICAL': 0, 'HIGH': 0}
    try:
        data = json.loads(json_output)
        results = data.get('Results', [])
        if not isinstance(results, list):
             results = [data] if data else []

        for result in results:
            vulnerabilities = result.get('Vulnerabilities', [])
            if vulnerabilities:
                for vuln in vulnerabilities:
                    severity = vuln.get('Severity')
                    if severity == 'CRITICAL':
                        counts['CRITICAL'] += 1
                    elif severity == 'HIGH':
                        counts['HIGH'] += 1
    except json.JSONDecodeError:
        print("Error: Failed to decode Trivy JSON output.", file=sys.stderr)
        return None
    except Exception as e:
        print(f"Error parsing Trivy output: {e}", file=sys.stderr)
        return None
    return counts

def scan_image_vulnerabilities_trivy(image_name, severity="HIGH,CRITICAL"):
    """
    Scans a Docker image using the locally installed Trivy CLI.
    Requires Trivy CLI to be installed and Docker daemon access (for pulling if needed).
    Returns a dictionary with vulnerability counts {'CRITICAL': count, 'HIGH': count} or None on error.
    """
    if not image_name:
        print("Error: No image name provided for Trivy scan.", file=sys.stderr)
        return None

    # Skip docker pull since we don't have docker socket permissions
    # Just proceed with scanning the image directly with trivy
    print(f"Scanning {image_name} with local Trivy CLI (Severity: {severity})...")

    print(f"Scanning {image_name} with local Trivy CLI (Severity: {severity})...")
    command = [
        "trivy", # Use local trivy command
        "image",
        "--format", "json",
        "--quiet",
        "--severity", severity,
        image_name
    ]
    try:
        process = subprocess.run(command, capture_output=True, text=True, check=False, timeout=600)
        if process.returncode == 0:
            return parse_trivy_output(process.stdout)
        elif process.returncode == 1 and "no vulnerabilities found" in process.stderr.lower():
             print(f"No {severity} vulnerabilities found by Trivy for {image_name}.")
             return {'CRITICAL': 0, 'HIGH': 0}
        elif process.returncode == 1:
             print(f"Vulnerabilities found by Trivy for {image_name} (exit code 1), parsing output...")
             return parse_trivy_output(process.stdout)
        else:
            print(f"Error running Trivy scan for {image_name} (Exit Code: {process.returncode}):", file=sys.stderr)
            print(f"Stderr: {process.stderr}", file=sys.stderr)
            return None
    except subprocess.TimeoutExpired:
        print(f"Error: Trivy scan for {image_name} timed out.", file=sys.stderr)
        return None
    except FileNotFoundError:
         # Now checks for 'trivy' or 'docker' if pull failed earlier
         print("Error: 'trivy' or 'docker' command not found. Are Trivy and Docker installed and in PATH?", file=sys.stderr)
         return None
    except Exception as e:
        print(f"An unexpected error occurred during Trivy scan: {e}", file=sys.stderr)
        return None

# --- Filesystem Scan Function (using local Trivy) ---

def scan_filesystem_vulnerabilities_trivy(fs_path, severity="HIGH,CRITICAL"):
    """
    Scans a filesystem path using the locally installed Trivy CLI.
    Requires Trivy CLI to be installed.
    Returns a dictionary with vulnerability counts {'CRITICAL': count, 'HIGH': count} or None on error.
    """
    if not fs_path:
        print("Error: No filesystem path provided for Trivy scan.", file=sys.stderr)
        return None

    print(f"Scanning filesystem path {fs_path} with local Trivy CLI (Severity: {severity})...")
    command = [
        "trivy", # Use local trivy command
        "fs",    # Filesystem scan
        "--format", "json",
        "--quiet",
        "--severity", severity,
        fs_path  # The path to scan
    ]
    try:
        process = subprocess.run(command, capture_output=True, text=True, check=False, timeout=600)
        # Reuse the same parsing logic as image scans
        if process.returncode == 0:
            return parse_trivy_output(process.stdout)
        elif process.returncode == 1 and "no vulnerabilities found" in process.stderr.lower():
             print(f"No {severity} vulnerabilities found by Trivy for path {fs_path}.")
             return {'CRITICAL': 0, 'HIGH': 0}
        elif process.returncode == 1:
             print(f"Vulnerabilities found by Trivy for path {fs_path} (exit code 1), parsing output...")
             return parse_trivy_output(process.stdout)
        else:
            print(f"Error running Trivy filesystem scan for {fs_path} (Exit Code: {process.returncode}):", file=sys.stderr)
            print(f"Stderr: {process.stderr}", file=sys.stderr)
            return None
    except subprocess.TimeoutExpired:
        print(f"Error: Trivy filesystem scan for {fs_path} timed out.", file=sys.stderr)
        return None
    except FileNotFoundError:
         print("Error: 'trivy' command not found. Is Trivy installed and in PATH?", file=sys.stderr)
         return None
    except Exception as e:
        print(f"An unexpected error occurred during Trivy filesystem scan: {e}", file=sys.stderr)
        return None

# --- GCP Specific Functions ---

def parse_gcloud_scan_output(json_output):
    """Parses the JSON output of 'gcloud artifacts docker images scan'."""
    counts = {'CRITICAL': 0, 'HIGH': 0}
    try:
        scan_data = json.loads(json_output)
        findings = scan_data.get("scan_results", {}).get("VULNERABILITY", {}).get("details", [])
        if not findings and "response" in scan_data:
             findings = scan_data.get("response", {}).get("scan_results", {}).get("VULNERABILITY", {}).get("details", [])
        if not findings:
             occurrences = scan_data if isinstance(scan_data, list) else []
             for occ in occurrences:
                 severity = occ.get("vulnerability", {}).get("effectiveSeverity", "SEVERITY_UNSPECIFIED")
                 if severity == 'CRITICAL':
                     counts['CRITICAL'] += 1
                 elif severity == 'HIGH':
                     counts['HIGH'] += 1
             if occurrences:
                 return counts
        for finding in findings:
            severity = finding.get('effectiveSeverity', 'SEVERITY_UNSPECIFIED')
            if severity == 'CRITICAL':
                counts['CRITICAL'] += 1
            elif severity == 'HIGH':
                counts['HIGH'] += 1
    except json.JSONDecodeError:
        print(f"Error: Failed to decode gcloud JSON output: {json_output}", file=sys.stderr)
        return None
    except Exception as e:
        print(f"Error parsing gcloud scan output: {e}", file=sys.stderr)
        print(f"Raw output: {json_output}", file=sys.stderr)
        return None
    return counts

def scan_image_vulnerabilities_gcp(image_name_full_path, severity="HIGH,CRITICAL"):
    """
    Scans a Docker image stored in GCR/Artifact Registry using 'gcloud artifacts docker images scan'.
    Requires gcloud CLI to be installed, authenticated, and the image to exist in GCP.
    Returns a dictionary with vulnerability counts {'CRITICAL': count, 'HIGH': count} or None on error.
    """
    if not image_name_full_path:
        print("Error: No full image path (e.g., gcr.io/project/image:tag) provided for gcloud scan.", file=sys.stderr)
        return None

    print(f"Scanning {image_name_full_path} using gcloud (Severity: {severity})...")
    command = [
        "gcloud",
        "artifacts",
        "docker",
        "images",
        "scan",
        image_name_full_path,
        "--format=json",
    ]
    if "gcr.io" in image_name_full_path:
        command[1] = "container"
        command.insert(3, "images")

    try:
        process = subprocess.run(command, capture_output=True, text=True, check=False, timeout=600)
        if process.returncode == 0:
            # Parse all severities, filtering happens in parse_gcloud_scan_output
            # Or adjust command flags if gcloud allows severity filtering directly in the scan command
            return parse_gcloud_scan_output(process.stdout)
        else:
            print(f"Error running gcloud scan for {image_name_full_path} (Exit Code: {process.returncode}):", file=sys.stderr)
            print(f"Stderr: {process.stderr}", file=sys.stderr)
            if "not found" in process.stderr.lower():
                 print(f"Hint: Ensure image '{image_name_full_path}' exists in GCP Artifact Registry/GCR.", file=sys.stderr)
            elif "permission denied" in process.stderr.lower() or "forbidden" in process.stderr.lower():
                 print("Hint: Check gcloud authentication and Artifact Registry/Container Analysis API permissions.", file=sys.stderr)
            return None
    except FileNotFoundError:
        print("Error: 'gcloud' command not found. Is Google Cloud SDK installed and in PATH?", file=sys.stderr)
        return None
    except subprocess.TimeoutExpired:
        print(f"Error: gcloud scan for {image_name_full_path} timed out.", file=sys.stderr)
        return None
    except Exception as e:
        print(f"An unexpected error occurred during gcloud scan: {e}", file=sys.stderr)
        return None

# --- Runtime Assessment Orchestration ---
import os
import shutil # For directory cleanup

def assess_runtime_vulnerabilities(target_identifier, target_type='docker', temp_base_dir='/tmp', severity="HIGH,CRITICAL"):
    """
    Assesses vulnerabilities in a running container's filesystem.
    Copies the filesystem locally, then scans it using local Trivy CLI.
    Requires Docker CLI or kubectl CLI, and local Trivy CLI.
    Args:
        target_identifier (str): Docker container ID/name or K8s pod name (e.g., "my-container" or "namespace/my-pod").
        target_type (str): 'docker' or 'k8s'. Defaults to 'docker'.
        temp_base_dir (str): Base directory for temporary filesystem copies.
        severity (str): Severities to report (e.g., "HIGH,CRITICAL").
    Returns:
        dict: Vulnerability counts {'CRITICAL': count, 'HIGH': count} or None on error.
    """
    if not target_identifier:
        print("Error: No target identifier provided for runtime assessment.", file=sys.stderr)
        return None

    # Create a unique temporary directory for this scan
    temp_dir_name = f"trivy_runtime_scan_{target_identifier.replace('/', '_')}_{os.getpid()}"
    temp_fs_path = os.path.join(temp_base_dir, temp_dir_name)

    copy_command = []
    source_path = f"{target_identifier}:/" # Path inside the container

    if target_type == 'docker':
        copy_command = ["docker", "cp", source_path, temp_fs_path]
        print(f"Copying filesystem from Docker container '{target_identifier}' to '{temp_fs_path}'...")
    elif target_type == 'k8s':
        copy_command = ["kubectl", "cp", source_path, temp_fs_path]
        print(f"Copying filesystem from Kubernetes pod '{target_identifier}' to '{temp_fs_path}'...")
    else:
        print(f"Error: Unsupported target_type '{target_type}'. Use 'docker' or 'k8s'.", file=sys.stderr)
        return None

    scan_results = None
    try:
        # Ensure temp dir exists
        os.makedirs(temp_fs_path, exist_ok=True)

        # Execute copy command
        copy_process = subprocess.run(copy_command, capture_output=True, text=True, check=False, timeout=600)
        if copy_process.returncode != 0:
            print(f"Error copying filesystem from {target_type} target '{target_identifier}' (Exit Code: {copy_process.returncode}):", file=sys.stderr)
            print(f"Stderr: {copy_process.stderr}", file=sys.stderr)
            return None # Cannot proceed without filesystem

        print(f"Filesystem copy complete. Starting Trivy scan...")
        # Scan the copied filesystem
        scan_results = scan_filesystem_vulnerabilities_trivy(temp_fs_path, severity)

    except FileNotFoundError:
        print(f"Error: '{copy_command[0]}' command not found. Is {target_type.upper()} CLI installed and in PATH?", file=sys.stderr)
        return None
    except subprocess.TimeoutExpired:
        print(f"Error: Filesystem copy from {target_identifier} timed out.", file=sys.stderr)
        return None
    except Exception as e:
        print(f"An unexpected error occurred during filesystem copy or scan setup: {e}", file=sys.stderr)
        return None
    finally:
        # Cleanup: Remove the temporary directory
        if os.path.exists(temp_fs_path):
            try:
                shutil.rmtree(temp_fs_path)
                print(f"Cleaned up temporary directory: {temp_fs_path}")
            except Exception as e:
                print(f"Warning: Failed to clean up temporary directory {temp_fs_path}: {e}", file=sys.stderr)

    return scan_results


# --- Main Dispatch Function (Renamed) ---

def assess_image_vulnerabilities(image_name, scanner_type="gcp", severity="HIGH,CRITICAL"):
    """
    Scans a Docker IMAGE for vulnerabilities using the specified scanner type.
    Args:
        image_name (str): The name of the image (full path required for gcp).
        scanner_type (str): 'gcp' or 'trivy'. Defaults to 'gcp'.
        severity (str): Comma-separated list of severities (e.g., "HIGH,CRITICAL").
    Returns:
        dict: Vulnerability counts {'CRITICAL': count, 'HIGH': count} or None on error.
    """
    if scanner_type == "gcp":
        # Note: Assumes image_name is the full path for GCP
        result = scan_image_vulnerabilities_gcp(image_name, severity)
        # GCP parsing currently handles severity filtering, but we pass severity for consistency
        # If gcloud command is updated to filter, parsing might simplify.
        return result
    elif scanner_type == "trivy":
        # Note: Assumes image_name is suitable for docker pull/trivy
        return scan_image_vulnerabilities_trivy(image_name, severity)
    else:
        print(f"Error: Unknown scanner type '{scanner_type}'. Use 'gcp' or 'trivy'.", file=sys.stderr)
        return None
# Example usage (for testing the module directly)
if __name__ == "__main__":
    # --- Test GCP Image Scan ---
    # Ensure gcloud is authenticated and image exists in GCR/AR
    # test_image_gcp = "us-central1-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0"
    # print(f"\n--- Testing GCP Image Scanner ---")
    # vuln_counts_gcp = assess_image_vulnerabilities(test_image_gcp, scanner_type="gcp")
    # if vuln_counts_gcp:
    #     print(f"GCP Scan Results for {test_image_gcp}: CRIT={vuln_counts_gcp['CRITICAL']}, HIGH={vuln_counts_gcp['HIGH']}")
    # else:
    #     print(f"GCP Scan failed for {test_image_gcp}.")

    # --- Test Trivy Image Scan (using local Trivy) ---
    # Ensure Docker is running (for pulling) and Trivy CLI is installed
    # test_image_trivy = "python:3.10-slim"
    # print(f"\n--- Testing Trivy Image Scanner (Local CLI) ---")
    # vuln_counts_trivy_img = assess_image_vulnerabilities(test_image_trivy, scanner_type="trivy")
    # if vuln_counts_trivy_img:
    #     print(f"Trivy Image Scan Results for {test_image_trivy}: CRIT={vuln_counts_trivy_img['CRITICAL']}, HIGH={vuln_counts_trivy_img['HIGH']}")
    # else:
    #     print(f"Trivy Image Scan failed for {test_image_trivy}.")

    # --- Test Trivy Runtime Scan (Docker) ---
    # Ensure Docker is running, Trivy CLI is installed, and a container exists
    # test_container_id = "YOUR_RUNNING_CONTAINER_ID_OR_NAME" # Replace with a real running container ID/Name
    # print(f"\n--- Testing Trivy Runtime Scanner (Docker Target) ---")
    # if test_container_id != "YOUR_RUNNING_CONTAINER_ID_OR_NAME":
    #     vuln_counts_runtime_docker = assess_runtime_vulnerabilities(test_container_id, target_type="docker")
    #     if vuln_counts_runtime_docker:
    #         print(f"Trivy Runtime Scan Results for Docker container {test_container_id}: CRIT={vuln_counts_runtime_docker['CRITICAL']}, HIGH={vuln_counts_runtime_docker['HIGH']}")
    #     else:
    #         print(f"Trivy Runtime Scan failed for Docker container {test_container_id}.")
    # else:
    #     print("Skipping Docker runtime test, please set 'test_container_id'.")

    # --- Test Trivy Runtime Scan (Kubernetes) ---
    # Ensure kubectl is configured, Trivy CLI is installed, and a pod exists
    # test_pod_name = "YOUR_NAMESPACE/YOUR_RUNNING_POD_NAME" # Replace with a real running pod name (namespace/name)
    # print(f"\n--- Testing Trivy Runtime Scanner (K8s Target) ---")
    # if test_pod_name != "YOUR_NAMESPACE/YOUR_RUNNING_POD_NAME":
    #     vuln_counts_runtime_k8s = assess_runtime_vulnerabilities(test_pod_name, target_type="k8s")
    #     if vuln_counts_runtime_k8s:
    #         print(f"Trivy Runtime Scan Results for K8s pod {test_pod_name}: CRIT={vuln_counts_runtime_k8s['CRITICAL']}, HIGH={vuln_counts_runtime_k8s['HIGH']}")
    #     else:
    #         print(f"Trivy Runtime Scan failed for K8s pod {test_pod_name}.")
    # else:
    #      print("Skipping K8s runtime test, please set 'test_pod_name'.")
    pass # Keep the file runnable